///imports math module, module already present in dart, no need to install
//show only imports a part of a library, in this case Random
import 'dart:math' show Random;

//void at the beggining specifies the type of return that the main function will have
//in dart the function called main is the entry point
//async has a similar function that in js, we needed in the function when we need to use the await keyword
void main() async {
  print('Compute π using the Monte Carlo method.'); //print prints text
  await for (final estimate in computePi().take(100)) {
    //take the first 100 values of computePi
    //for loop like js
    //the estimate variable is a final type because we dont intend to change its value
    //computePi is a function describe down
    print('π ≅ $estimate');
  }
}

/// Generates a stream of increasingly accurate estimates of π.
//Return type: Stream of doubles
//double=integers with commas
//A stream is a sequence of asynchronous events. It is like an asynchronous Iterable—where, instead of getting the next event when
//you ask for it, the stream tells you that there is an event when it is ready.
Stream<double> computePi({int batch = 100000}) async* {
  var total = 0; // Inferred to be of type int
  var count = 0;
  while (true) {
    //it will repeat until the 100 values
    final points = generateRandom()
        .take(batch); //take takes the number of numbers generated by
    //generateRandom, takes 100000 numbers
    //print("points ${points}"); (point, point, point) returned
    final inside = points.where((p) => p
        .isInsideUnitCircle); //calls the getter method of the point class called isInsideUnitCircle
    //elevate to the square the two points and adds them, then if is bigger than 1 the point doesnt pass to the inside variable
    //if is 1 or smaller is stored in the inside variable
    //in my first run 78315 points accomplished this condition

    total += batch; //100000, 200000 in 2nd iteration, 300000 in 3rd and so on
    count += inside
        .length; //length of inside variable, 78315, in the 2nd iteration whe add 78315 with the new inside (78390)
    //to return 156705, and then whe add the inside of the third iteration and so on
    print("count ${count}");
    final ratio = count / total; //ratio 0,78315

    // Area of a circle is A = π⋅r², therefore π = A/r².
    // So, when given random points with x ∈ <0,1>,
    // y ∈ <0,1>, the ratio of those inside a unit circle
    // should approach π / 4. Therefore, the value of π
    // should be:
    yield ratio * 4; //3,1326
  }
}
//An Iterable is a collection of elements that can be accessed sequentially.
//In Dart, an Iterable is an abstract class, meaning that you can’t instantiate it directly. However, you can create a new
//Iterable by creating a new List or Set.

//Point comes from the math library
//A utility class for representing two-dimensional positions.
//Example:
//const Point(0, 0)
//When you need to lazily produce a sequence of values, consider using a generator function. Dart has built-in support for two
//kinds of generator functions:
//Synchronous generator: Returns an Iterable object.
//Asynchronous generator: Returns a Stream object.
//To implement a synchronous generator function, mark the function body as sync*, and use yield statements to deliver values:
Iterable<Point> generateRandom([int? seed]) sync* {
  //returns an iterable object with the form of a Point class
  //print("seed ${seed}"); seed is optional, null in this code
  final random = Random(seed);
  while (true) {
    yield Point(
        random.nextDouble(),
        random
            .nextDouble()); //return two dimensional position with random values
  }
}

class Point {
  final double
      x; //x is a double variable (number with coma and decimal) and is final
  final double y;
//a const variable is a compile-time constant.
//meaning that it computes when the code compiles
//compute=calculate using a machine
//compile=converts dart code to machine code
  const Point(this.x, this.y); //a point object consist in (x, y)

  bool get isInsideUnitCircle =>
      x * x + y * y <= 1; //metodo getter isInsideUnitCircle
}
